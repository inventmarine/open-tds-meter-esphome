substitutions:
  devicename: open-tds
  tds_name_1: "TDS Sensor 1"
  tds_name_2: "TDS Sensor 2"
  # Voltage divider ratio - adjust based on your setup:
  # 1.0 = No divider (sensor outputs 0-1V)
  # 2.32 = 10k立 + 4.7k立 resistors (14.7/4.7 = 3.128, but use measured value)
  # 2.5 = 15k立 + 10k立 resistors
  voltage_divider_1: "2.32"
  voltage_divider_2: "2.32"

esphome:
  name: $devicename

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG
  logs:
    sensor: WARN

# Enable Home Assistant API
api:
  password: ""

ota:
  - platform: esphome
    password: ""

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${devicename} Hotspot"
    password: !secret wifi_hotspot_pwd

captive_portal:

# Global variables for calibration
globals:
  - id: k_value_1
    type: float
    restore_value: yes
    initial_value: '1.0'  # K-value for sensor 1
  - id: k_value_2
    type: float
    restore_value: yes
    initial_value: '1.0'  # K-value for sensor 2
  - id: water_temperature
    type: float
    restore_value: yes
    initial_value: '19.0'  # Default water temperature in Celsius

text_sensor:
  - platform: wifi_info
    ip_address:
      name: ESP IP Address
      id: ip_add
    ssid:
      name: ESP Connected SSID
    bssid:
      name: ESP Connected BSSID

sensor:
  # Raw ADC reading - Sensor 1
  - platform: adc
    pin: GPIO33
    name: "${tds_name_1} Raw ADC"
    id: tds_raw_1
    attenuation: 12db
    update_interval: 500ms
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 2
    on_value:
      then:
        - logger.log:
            format: "Sensor 1 ADC: Raw=%d, Voltage=%.3fV"
            args:
              - 'int(x * 4095.0 / 3.3)'
              - 'x'
            level: INFO

  # Raw ADC reading - Sensor 2
  - platform: adc
    pin: GPIO32
    name: "${tds_name_2} Raw ADC"
    id: tds_raw_2
    attenuation: 12db
    update_interval: 500ms
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 2
    on_value:
      then:
        - logger.log:
            format: "Sensor 2 ADC: Raw=%d, Voltage=%.3fV"
            args:
              - 'int(x * 4095.0 / 3.3)'
              - 'x'
            level: INFO

  # Direct voltage reading - Sensor 1
  - platform: template
    name: "${tds_name_1} Voltage"
    id: tds_voltage_1
    unit_of_measurement: "V"
    update_interval: 3s
    lambda: |-
      return id(tds_raw_1).state;
    on_value:
      then:
        - logger.log:
            format: "Sensor 1 Voltage: %.3f V"
            args: ['x']
            level: INFO

  # Direct voltage reading - Sensor 2
  - platform: template
    name: "${tds_name_2} Voltage"
    id: tds_voltage_2
    unit_of_measurement: "V"
    update_interval: 1s
    lambda: |-
      return id(tds_raw_2).state;
    on_value:
      then:
        - logger.log:
            format: "Sensor 2 Voltage: %.3f V"
            args: ['x']
            level: INFO

  # TDS calculation with linear formula - Sensor 1
  - platform: template
    name: "${tds_name_1}"
    id: tds_direct_1
    unit_of_measurement: "ppm"
    icon: "mdi:water-opacity"
    update_interval: 1s
    lambda: |-
      float adc_voltage = id(tds_voltage_1).state;
      float actual_voltage = adc_voltage * ${voltage_divider_1};
      
      // Linear formula based on calibration points:
      // 3ppm @ 0.329V, 90ppm @ 0.487V (updated based on actual measurements)
      // Slope = (90-3)/(0.487-0.329) = 550.6 ppm/V
      // Offset = 3 - 550.6*0.329 = -178.0
      float slope = 550.6;
      float offset = -178.0;
      float tds = slope * actual_voltage + offset;
      
      // Apply individual K-value calibration if needed
      tds = tds * id(k_value_1);
      
      if (tds < 0) tds = 0;
      if (tds > 2000) tds = 2000;
      
      float raw_linear = slope * actual_voltage + offset;
      ESP_LOGI("tds1", "TDS1: ADC=%.3f, V=%.3f, RawLinear=%.1f, K=%.3f, Final=%.1f ppm", 
               adc_voltage, actual_voltage, raw_linear, id(k_value_1), tds);
      
      return tds;

  # TDS calculation with linear formula - Sensor 2
  - platform: template
    name: "${tds_name_2}"
    id: tds_direct_2
    unit_of_measurement: "ppm"
    icon: "mdi:water-opacity"
    update_interval: 1s
    lambda: |-
      float adc_voltage = id(tds_voltage_2).state;
      float actual_voltage = adc_voltage * ${voltage_divider_2};
      
      // Linear formula based on calibration points:
      // 3ppm @ 0.329V, 90ppm @ 0.487V (updated based on actual measurements)
      // Slope = (90-3)/(0.487-0.329) = 550.6 ppm/V
      // Offset = 3 - 550.6*0.329 = -178.0
      float slope = 550.6;
      float offset = -178.0;
      float tds = slope * actual_voltage + offset;
      
      // Apply individual K-value calibration if needed
      tds = tds * id(k_value_2);
      
      if (tds < 0) tds = 0;
      if (tds > 2000) tds = 2000;
      
      float raw_linear = slope * actual_voltage + offset;
      ESP_LOGI("tds2", "TDS2: ADC=%.3f, V=%.3f, RawLinear=%.1f, K=%.3f, Final=%.1f ppm", 
               adc_voltage, actual_voltage, raw_linear, id(k_value_2), tds);
      
      return tds;

  # K-value sensor for monitoring - Sensor 1
  - platform: template
    name: "TDS K-Value Sensor 1"
    id: k_value_sensor_1
    unit_of_measurement: ""
    accuracy_decimals: 3
    update_interval: 5s
    lambda: |-
      return id(k_value_1);
      
  # K-value sensor for monitoring - Sensor 2
  - platform: template
    name: "TDS K-Value Sensor 2"
    id: k_value_sensor_2
    unit_of_measurement: ""
    accuracy_decimals: 3
    update_interval: 5s
    lambda: |-
      return id(k_value_2);
      
  # Raw TDS without calibration - Sensor 1
  - platform: template
    name: "${tds_name_1} Raw (No Cal)"
    id: tds_raw_uncal_1
    unit_of_measurement: "ppm"
    icon: "mdi:water-opacity"
    update_interval: 1s
    lambda: |-
      float adc_voltage = id(tds_voltage_1).state;
      float actual_voltage = adc_voltage * ${voltage_divider_1};
      float temperature = id(water_temperature);
      float compensationCoefficient = 1.0 + 0.02 * (temperature - 25.0);
      float compensationVoltage = actual_voltage / compensationCoefficient;
      
      float tds = (133.42 * compensationVoltage * compensationVoltage * compensationVoltage - 
                   255.86 * compensationVoltage * compensationVoltage + 
                   857.39 * compensationVoltage) * 0.5;
      
      if (tds < 0) tds = 0;
      if (tds > 2000) tds = 2000;
      
      return tds;
      
  # Raw TDS without calibration - Sensor 2
  - platform: template
    name: "${tds_name_2} Raw (No Cal)"
    id: tds_raw_uncal_2
    unit_of_measurement: "ppm"
    icon: "mdi:water-opacity"
    update_interval: 1s
    lambda: |-
      float adc_voltage = id(tds_voltage_2).state;
      float actual_voltage = adc_voltage * ${voltage_divider_2};
      float temperature = id(water_temperature);
      float compensationCoefficient = 1.0 + 0.02 * (temperature - 25.0);
      float compensationVoltage = actual_voltage / compensationCoefficient;
      
      float tds = (133.42 * compensationVoltage * compensationVoltage * compensationVoltage - 
                   255.86 * compensationVoltage * compensationVoltage + 
                   857.39 * compensationVoltage) * 0.5;
      
      if (tds < 0) tds = 0;
      if (tds > 2000) tds = 2000;
      
      return tds;
      
  # Voltage test sensors - show actual voltages for debugging
  - platform: template
    name: "${tds_name_1} Actual Voltage"
    id: voltage_actual_1
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: 2s
    lambda: |-
      return id(tds_voltage_1).state * ${voltage_divider_1};
      
  - platform: template
    name: "${tds_name_2} Actual Voltage"
    id: voltage_actual_2
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: 2s
    lambda: |-
      return id(tds_voltage_2).state * ${voltage_divider_2};


# OLED Display
i2c:
  sda: GPIO21
  scl: GPIO22
  frequency: 400kHz

font:
  - file: "gfonts://Roboto"
    id: font_xs
    size: 8
  - file: "gfonts://Roboto"
    id: font_sm
    size: 10
  - file: "gfonts://Roboto"
    id: font_md
    size: 12
  - file: "gfonts://Roboto"
    id: font_lg
    size: 16
  - file: "gfonts://Roboto"
    id: font_xl
    size: 20

color:
  - id: light_red
    red: 100%
    green: 20%
    blue: 25%
  - id: light_green
    red: 0%
    green: 100%
    blue: 25%
  - id: light_yellow
    red: 100%
    green: 100%
    blue: 0%
  - id: light_blue
    red: 25%
    green: 50%
    blue: 100%


display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    update_interval: 500ms
    lambda: |-
      // Title
      it.printf(64, 0, id(font_md), TextAlign::TOP_CENTER, "TDS MONITOR");
      
      // Draw vertical divider line (half height, centered)
      it.line(64, 20, 64, 48);
      
      // Sensor 1 - Left side
      it.printf(32, 20, id(font_xl), TextAlign::TOP_CENTER, "%.0f", id(tds_direct_1).state);
      it.printf(32, 40, id(font_sm), TextAlign::TOP_CENTER, "ppm");
      it.printf(32, 54, id(font_sm), TextAlign::TOP_CENTER, "Before");
      
      // Sensor 2 - Right side
      it.printf(96, 20, id(font_xl), TextAlign::TOP_CENTER, "%.0f", id(tds_direct_2).state);
      it.printf(96, 40, id(font_sm), TextAlign::TOP_CENTER, "ppm");
      it.printf(96, 54, id(font_sm), TextAlign::TOP_CENTER, "After");
      
#      // Status line 1
#      if (id(tds_voltage_1).state < 0.05) {
#        it.printf(0, 44, id(font_sm), "S1: CHECK!");
#      } else if (id(tds_direct_1).state < 50) {
#        it.printf(0, 44, id(font_sm), "S1: Excellent");
#      } else if (id(tds_direct_1).state < 150) {
#        it.printf(0, 44, id(font_sm), "S1: Good");
#      } else if (id(tds_direct_1).state < 250) {
#        it.printf(0, 44, id(font_sm), "S1: Fair");
#      } else {
#        it.printf(0, 44, id(font_sm), "S1: Poor");
#      }
#
#      // Status line 2
#      if (id(tds_voltage_2).state < 0.05) {
#        it.printf(0, 54, id(font_sm), "S2: CHECK!");
#      } else if (id(tds_direct_2).state < 50) {
#        it.printf(0, 54, id(font_sm), "S2: Excellent");
#      } else if (id(tds_direct_2).state < 150) {
#        it.printf(0, 54, id(font_sm), "S2: Good");
#      } else if (id(tds_direct_2).state < 250) {
#        it.printf(0, 54, id(font_sm), "S2: Fair");
#      } else {
#        it.printf(0, 54, id(font_sm), "S2: Poor");
#      }

# Status LED (built-in on most ESP32 boards)
output:
  - platform: gpio
    pin: GPIO2
    id: status_led

# Diagnostic info every 5 seconds
interval:
  - interval: 5s
    then:
      - logger.log:
          format: "\n========== TDS DIAGNOSTIC ==========\nSENSOR 1:\n  RAW ADC: %d / 4095\n  Voltage: %.3f V\n  TDS: %.1f ppm\n\nSENSOR 2:\n  RAW ADC: %d / 4095\n  Voltage: %.3f V\n  TDS: %.1f ppm\n\nCONNECTIONS:\n1. VCC -> ESP32 5V\n2. GND -> ESP32 GND\n3. Sensor1 -> GPIO33\n4. Sensor2 -> GPIO32\n===================================="
          args:
            - 'int(id(tds_raw_1).state * 4095.0 / 3.3)'
            - 'id(tds_voltage_1).state'
            - 'id(tds_direct_1).state'
            - 'int(id(tds_raw_2).state * 4095.0 / 3.3)'
            - 'id(tds_voltage_2).state'
            - 'id(tds_direct_2).state'
          level: WARN

      # Blink LED based on readings
      - if:
          condition:
            lambda: 'return id(tds_voltage_1).state < 0.1 || id(tds_voltage_2).state < 0.1;'
          then:
            # Fast blink for very low reading
            - output.turn_on: status_led
            - delay: 100ms
            - output.turn_off: status_led
            - logger.log: "WARNING: Very low reading! Check wiring!"
          else:
            # Normal blink
            - output.turn_on: status_led
            - delay: 500ms
            - output.turn_off: status_led

# Web server for easy debugging
web_server:
  port: 80

# Calibration inputs and controls
number:
  - platform: template
    name: "TDS Cal Reference - Sensor 1 (ppm)"
    id: calibration_reference_1
    min_value: 0
    max_value: 2000
    step: 1
    initial_value: 90  # Your calibration solution
    restore_value: yes
    unit_of_measurement: "ppm"
    optimistic: true
    
  - platform: template
    name: "TDS Cal Reference - Sensor 2 (ppm)"
    id: calibration_reference_2
    min_value: 0
    max_value: 2000
    step: 1
    initial_value: 90  # Your calibration solution
    restore_value: yes
    unit_of_measurement: "ppm"
    optimistic: true

button:
  - platform: template
    name: "Calibrate TDS Sensor 1"
    id: calibrate_button_1
    on_press:
      then:
        - logger.log:
            format: "Starting calibration for Sensor 1 with reference: %.0f ppm"
            args: ['id(calibration_reference_1).state']
            level: INFO
        - delay: 2s  # Allow readings to stabilize
        - lambda: |-
            float adc_voltage = id(tds_voltage_1).state;
            float actual_voltage = adc_voltage * ${voltage_divider_1};
            
            // Linear formula calibration
            float slope = 654.1;
            float offset = -212.3;
            float measured_tds = slope * actual_voltage + offset;
            
            // Calculate K-value as correction factor
            float reference_tds = id(calibration_reference_1).state;
            if (measured_tds > 0) {
              id(k_value_1) = reference_tds / measured_tds;
              ESP_LOGI("cal", "Sensor 1 calibration: V=%.3f, Measured=%.1f ppm, Reference=%.1f ppm, K=%.3f", 
                       actual_voltage, measured_tds, reference_tds, id(k_value_1));
            } else {
              ESP_LOGE("cal", "Invalid reading from Sensor 1. Calibration failed.");
            }
            
  - platform: template
    name: "Calibrate TDS Sensor 2"
    id: calibrate_button_2
    on_press:
      then:
        - logger.log:
            format: "Starting calibration for Sensor 2 with reference: %.0f ppm"
            args: ['id(calibration_reference_2).state']
            level: INFO
        - delay: 2s  # Allow readings to stabilize
        - lambda: |-
            float adc_voltage = id(tds_voltage_2).state;
            float actual_voltage = adc_voltage * ${voltage_divider_2};
            
            // Linear formula calibration
            float slope = 654.1;
            float offset = -212.3;
            float measured_tds = slope * actual_voltage + offset;
            
            // Calculate K-value as correction factor
            float reference_tds = id(calibration_reference_2).state;
            if (measured_tds > 0) {
              id(k_value_2) = reference_tds / measured_tds;
              ESP_LOGI("cal", "Sensor 2 calibration: V=%.3f, Measured=%.1f ppm, Reference=%.1f ppm, K=%.3f", 
                       actual_voltage, measured_tds, reference_tds, id(k_value_2));
            } else {
              ESP_LOGE("cal", "Invalid reading from Sensor 2. Calibration failed.");
            }
            
  - platform: template
    name: "Reset TDS Calibration - Sensor 1"
    id: reset_calibration_button_1
    on_press:
      then:
        - globals.set:
            id: k_value_1
            value: '1.0'
        - logger.log: "TDS calibration reset to default (K=1.0) for Sensor 1"
        
  - platform: template
    name: "Reset TDS Calibration - Sensor 2"
    id: reset_calibration_button_2
    on_press:
      then:
        - globals.set:
            id: k_value_2
            value: '1.0'
        - logger.log: "TDS calibration reset to default (K=1.0) for Sensor 2"