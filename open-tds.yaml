substitutions:
  devicename: open-tds
  tds_name_1: "TDS Sensor 1"
  tds_name_2: "TDS Sensor 2"
  # Voltage divider ratio - adjust based on your setup:
  # 1.0 = No divider (sensor outputs 0-1V)
  # 2.32 = 10k立 + 4.7k立 resistors (14.7/4.7 = 3.128, but use measured value)
  # 2.5 = 15k立 + 10k立 resistors
  voltage_divider_1: "2.32"
  voltage_divider_2: "2.32"

esphome:
  name: $devicename

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG
  logs:
    sensor: DEBUG

# Enable Home Assistant API
api:
  password: ""

ota:
  - platform: esphome
    password: ""

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${devicename} Hotspot"
    password: !secret wifi_hotspot_pwd

captive_portal:

# Global variables for calibration
globals:
  - id: k_value
    type: float
    restore_value: yes
    initial_value: '1.0'  # Shared K-value for both sensors
  - id: calibration_in_progress
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: calibration_sensor
    type: int
    restore_value: no
    initial_value: '1'  # Which sensor to use for calibration (1 or 2)

text_sensor:
  - platform: wifi_info
    ip_address:
      name: ESP IP Address
      id: ip_add
    ssid:
      name: ESP Connected SSID
    bssid:
      name: ESP Connected BSSID

sensor:
  # Raw ADC reading - Sensor 1
  - platform: adc
    pin: GPIO33
    name: "${tds_name_1} Raw ADC"
    id: tds_raw_1
    attenuation: 12db
    update_interval: 500ms
    on_value:
      then:
        - logger.log:
            format: "Sensor 1 ADC: Raw=%d, Voltage=%.3fV"
            args:
              - 'int(x * 4095.0 / 3.3)'
              - 'x'
            level: INFO

  # Raw ADC reading - Sensor 2
  - platform: adc
    pin: GPIO32
    name: "${tds_name_2} Raw ADC"
    id: tds_raw_2
    attenuation: 12db
    update_interval: 500ms
    on_value:
      then:
        - logger.log:
            format: "Sensor 2 ADC: Raw=%d, Voltage=%.3fV"
            args:
              - 'int(x * 4095.0 / 3.3)'
              - 'x'
            level: INFO

  # Direct voltage reading - Sensor 1
  - platform: template
    name: "${tds_name_1} Voltage"
    id: tds_voltage_1
    unit_of_measurement: "V"
    update_interval: 3s
    lambda: |-
      return id(tds_raw_1).state;
    on_value:
      then:
        - logger.log:
            format: "Sensor 1 Voltage: %.3f V"
            args: ['x']
            level: INFO

  # Direct voltage reading - Sensor 2
  - platform: template
    name: "${tds_name_2} Voltage"
    id: tds_voltage_2
    unit_of_measurement: "V"
    update_interval: 1s
    lambda: |-
      return id(tds_raw_2).state;
    on_value:
      then:
        - logger.log:
            format: "Sensor 2 Voltage: %.3f V"
            args: ['x']
            level: INFO

  # TDS calculation with calibration - Sensor 1
  - platform: template
    name: "${tds_name_1}"
    id: tds_direct_1
    unit_of_measurement: "ppm"
    icon: "mdi:water-opacity"
    update_interval: 1s
    lambda: |-
      float voltage = id(tds_voltage_1).state;
      float temperature = 25.0;
      float compensationCoefficient = 1.0 + 0.02 * (temperature - 25.0);
      float compensationVoltage = voltage / compensationCoefficient;
      
      float tds = (133.42 * compensationVoltage * compensationVoltage * compensationVoltage - 
                   255.86 * compensationVoltage * compensationVoltage + 
                   857.39 * compensationVoltage) * id(k_value) * 0.5;
      
      if (tds < 0) tds = 0;
      if (tds > 2000) tds = 2000;
      
      ESP_LOGI("tds1", "TDS1: V=%.3f, K=%.3f, TDS=%.1f ppm", voltage, id(k_value), tds);
      
      return tds;

  # TDS calculation with calibration - Sensor 2
  - platform: template
    name: "${tds_name_2}"
    id: tds_direct_2
    unit_of_measurement: "ppm"
    icon: "mdi:water-opacity"
    update_interval: 1s
    lambda: |-
      float voltage = id(tds_voltage_2).state;
      float temperature = 25.0;
      float compensationCoefficient = 1.0 + 0.02 * (temperature - 25.0);
      float compensationVoltage = voltage / compensationCoefficient;
      
      float tds = (133.42 * compensationVoltage * compensationVoltage * compensationVoltage - 
                   255.86 * compensationVoltage * compensationVoltage + 
                   857.39 * compensationVoltage) * id(k_value) * 0.5;
      
      if (tds < 0) tds = 0;
      if (tds > 2000) tds = 2000;
      
      ESP_LOGI("tds2", "TDS2: V=%.3f, K=%.3f, TDS=%.1f ppm", voltage, id(k_value), tds);
      
      return tds;

  # K-value sensor for monitoring (shared by both sensors)
  - platform: template
    name: "TDS K-Value"
    id: k_value_sensor
    unit_of_measurement: ""
    accuracy_decimals: 3
    update_interval: 5s
    lambda: |-
      return id(k_value);


# OLED Display
i2c:
  sda: GPIO21
  scl: GPIO22
  frequency: 400kHz

font:
  - file: "gfonts://Roboto"
    id: font_xs
    size: 8
  - file: "gfonts://Roboto"
    id: font_sm
    size: 10
  - file: "gfonts://Roboto"
    id: font_md
    size: 12
  - file: "gfonts://Roboto"
    id: font_lg
    size: 16
  - file: "gfonts://Roboto"
    id: font_xl
    size: 20

color:
  - id: light_red
    red: 100%
    green: 20%
    blue: 25%
  - id: light_green
    red: 0%
    green: 100%
    blue: 25%
  - id: light_yellow
    red: 100%
    green: 100%
    blue: 0%
  - id: light_blue
    red: 25%
    green: 50%
    blue: 100%


display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    update_interval: 500ms
    lambda: |-
      // Title
      if (id(calibration_in_progress)) {
        it.printf(64, 0, id(font_md), TextAlign::TOP_CENTER, "CALIBRATING...");
      } else {
        it.printf(64, 0, id(font_md), TextAlign::TOP_CENTER, "TDS MONITOR");
      }
      
      // Draw vertical divider line (half height, centered)
      it.line(64, 16, 64, 48);
      
      // Sensor 1 - Left side
      it.printf(32, 20, id(font_xl), TextAlign::TOP_CENTER, "%.0f", id(tds_direct_1).state);
      it.printf(32, 40, id(font_sm), TextAlign::TOP_CENTER, "ppm");
      it.printf(32, 54, id(font_xs), TextAlign::TOP_CENTER, "Before");
      
      // Sensor 2 - Right side
      it.printf(96, 20, id(font_xl), TextAlign::TOP_CENTER, "%.0f", id(tds_direct_2).state);
      it.printf(96, 40, id(font_sm), TextAlign::TOP_CENTER, "ppm");
      it.printf(96, 54, id(font_xs), TextAlign::TOP_CENTER, "After");
      
#      // Status line 1
#      if (id(tds_voltage_1).state < 0.05) {
#        it.printf(0, 44, id(font_sm), "S1: CHECK!");
#      } else if (id(tds_direct_1).state < 50) {
#        it.printf(0, 44, id(font_sm), "S1: Excellent");
#      } else if (id(tds_direct_1).state < 150) {
#        it.printf(0, 44, id(font_sm), "S1: Good");
#      } else if (id(tds_direct_1).state < 250) {
#        it.printf(0, 44, id(font_sm), "S1: Fair");
#      } else {
#        it.printf(0, 44, id(font_sm), "S1: Poor");
#      }
#
#      // Status line 2
#      if (id(tds_voltage_2).state < 0.05) {
#        it.printf(0, 54, id(font_sm), "S2: CHECK!");
#      } else if (id(tds_direct_2).state < 50) {
#        it.printf(0, 54, id(font_sm), "S2: Excellent");
#      } else if (id(tds_direct_2).state < 150) {
#        it.printf(0, 54, id(font_sm), "S2: Good");
#      } else if (id(tds_direct_2).state < 250) {
#        it.printf(0, 54, id(font_sm), "S2: Fair");
#      } else {
#        it.printf(0, 54, id(font_sm), "S2: Poor");
#      }

# Status LED (built-in on most ESP32 boards)
output:
  - platform: gpio
    pin: GPIO2
    id: status_led

# Diagnostic info every 5 seconds
interval:
  - interval: 5s
    then:
      - logger.log:
          format: "\n========== TDS DIAGNOSTIC ==========\nSENSOR 1:\n  RAW ADC: %d / 4095\n  Voltage: %.3f V\n  TDS: %.1f ppm\n\nSENSOR 2:\n  RAW ADC: %d / 4095\n  Voltage: %.3f V\n  TDS: %.1f ppm\n\nCONNECTIONS:\n1. VCC -> ESP32 5V\n2. GND -> ESP32 GND\n3. Sensor1 -> GPIO33\n4. Sensor2 -> GPIO32\n===================================="
          args:
            - 'int(id(tds_raw_1).state * 4095.0 / 3.3)'
            - 'id(tds_voltage_1).state'
            - 'id(tds_direct_1).state'
            - 'int(id(tds_raw_2).state * 4095.0 / 3.3)'
            - 'id(tds_voltage_2).state'
            - 'id(tds_direct_2).state'
          level: WARN

      # Blink LED based on readings
      - if:
          condition:
            lambda: 'return id(tds_voltage_1).state < 0.1 || id(tds_voltage_2).state < 0.1;'
          then:
            # Fast blink for very low reading
            - output.turn_on: status_led
            - delay: 100ms
            - output.turn_off: status_led
            - logger.log: "WARNING: Very low reading! Check wiring!"
          else:
            # Normal blink
            - output.turn_on: status_led
            - delay: 500ms
            - output.turn_off: status_led

# Web server for easy debugging
web_server:
  port: 80

# Calibration inputs and controls
number:
  - platform: template
    name: "TDS Calibration Reference (ppm)"
    id: calibration_reference
    min_value: 0
    max_value: 2000
    step: 1
    initial_value: 1413  # Common calibration solution
    restore_value: yes
    unit_of_measurement: "ppm"
    optimistic: true
    
  - platform: template
    name: "Calibration Sensor Select"
    id: calibration_sensor_select
    min_value: 1
    max_value: 2
    step: 1
    initial_value: 1
    optimistic: true
    on_value:
      then:
        - globals.set:
            id: calibration_sensor
            value: !lambda 'return int(x);'

button:
  - platform: template
    name: "Calibrate TDS Sensors"
    id: calibrate_button
    on_press:
      then:
        - globals.set:
            id: calibration_in_progress
            value: 'true'
        - logger.log:
            format: "Starting calibration using Sensor %d with reference: %.0f ppm"
            args: ['id(calibration_sensor)', 'id(calibration_reference).state']
            level: INFO
        - delay: 3s  # Allow readings to stabilize
        - lambda: |-
            // Get voltage reading from selected sensor
            float voltage = id(calibration_sensor) == 1 ? id(tds_voltage_1).state : id(tds_voltage_2).state;
            float temperature = 25.0;
            float compensationCoefficient = 1.0 + 0.02 * (temperature - 25.0);
            float compensationVoltage = voltage / compensationCoefficient;
            
            // Calculate raw EC value without K
            float rawEC = 133.42 * compensationVoltage * compensationVoltage * compensationVoltage - 
                          255.86 * compensationVoltage * compensationVoltage + 
                          857.39 * compensationVoltage;
            
            // Calculate new K-value
            float referenceEC = id(calibration_reference).state / 0.5;  // Convert ppm to EC
            if (rawEC > 0) {
              id(k_value) = referenceEC / rawEC;
              ESP_LOGI("calibration", "Calibration complete. New K-value: %.3f (applied to both sensors)", id(k_value));
            } else {
              ESP_LOGE("calibration", "Invalid reading from Sensor %d. Calibration failed.", id(calibration_sensor));
            }
        - globals.set:
            id: calibration_in_progress
            value: 'false'
            
  - platform: template
    name: "Reset TDS Calibration"
    id: reset_calibration_button
    on_press:
      then:
        - globals.set:
            id: k_value
            value: '1.0'
        - logger.log: "TDS calibration reset to default (K=1.0) for both sensors"